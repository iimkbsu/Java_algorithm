/*
 분할정복 : 방대한 문제 해결에서 상단에서 분할, 중단에서 정복, 하단에서 조합 하는 형태로 여러 알고리즘의 기본 형태
 장점 - 어려운 문제를 해결할 수 있음
 단점 - 재귀적 함수 호출로 인해 오버헤드 발생, 스택 오버플로우 발생가능성, 과도한 메모리 사용 등
 
 분할정복 종류: 탐색 알고리즘, 정렬 알고리즘, 선택 알고리즘
 탐색 : 이진탐색
 정렬 : 퀵정렬, 합병(병합)정렬, 부분정렬
 선택 : 선형시간 선택
 
 
 그 외의 정렬 알고리즘 : 선택정렬(제자리 정렬 알고리즘), 삽입정렬, 버블정렬, 기수정렬
 ********************************************************************************
 
 버블정렬 : 인접한 데이터의 크기를 비교하여 서로 바꿔줌으로써 데이터 정렬
 시간복잡도 : O(n^2) 느린 편
 
 방식 (오름차순일 경우)
 42 32 24 60 15 (주어진 자료)
 
 32 42 24 60 15 (1-2)
 32 24 42 60 15 (2-3)
 32 24 42 60 15 (3-4)
 32 24 42 15 [60] (4-5) (5번째 수가 가장 큼, 1회 순환 완료)
 
 24 32 42 15 [60] (1-2)
 24 32 42 15 [60] (2-3)
 24 32 15 [42] [60] (3-4) (4번쨰 수가 두 번째로 큼, 2회 순환 완료)
 
 .....
 
 [15] [24] [32] [42] [60] (모든 수 오름차순 정렬, 5회 순환 완료)
 
 특징 : 순환도중 정렬이 한 번도 안 일어난 루프가 있을 경우 정렬이 완료된 상태이므로 종료
 */




package basic_algorithm.bubblesortAlgorithm;

public class bubblesortExample {
	
	public static void main(String[] args) {
		
		int[] bubble = {5,3,1,2,4};
		
		//오름차순 정렬
		for(int i=0; i<bubble.length; i++) {
			for(int j=0; j<bubble.length-i-1; j++) {
				if(bubble[j] > bubble[j+1]) {
					int tmp = bubble[j];
					bubble[j] = bubble[j+1];
					bubble[j+1] = tmp;
				}
			}
			
		}
		
		for(int i=0; i<bubble.length; i++) {
			System.out.print(bubble[i]+", ");
		}
		
	}

}





