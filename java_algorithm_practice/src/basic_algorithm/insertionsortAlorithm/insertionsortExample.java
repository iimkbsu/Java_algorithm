/*
 
 분할정복 : 방대한 문제 해결에서 상단에서 분할, 중단에서 정복, 하단에서 조합 하는 형태로 여러 알고리즘의 기본 형태
 장점 - 어려운 문제를 해결할 수 있음
 단점 - 재귀적 함수 호출로 인해 오버헤드 발생, 스택 오버플로우 발생가능성, 과도한 메모리 사용 등
 
 분할정복 종류: 탐색 알고리즘, 정렬 알고리즘, 선택 알고리즘
 탐색 : 이진탐색
 정렬 : 퀵정렬, 합병(병합)정렬, 부분정렬
 선택 : 선형시간 선택
 
 
 그 외의 정렬 알고리즘 : 선택정렬(제자리 정렬 알고리즘), 삽입정렬, 버블정렬, 기수정렬
 ********************************************************************************


 삽입정렬 : 두 번째 인덱스부터 시작하여 왼쪽 데이터와 비교하여 차순으로 자리교체 반복
 시간복잡도 : O(n^2) 버블정렬 선택정렬보다는 빠름
 
 방식 (오름차순일 경우)
 42 32 24 60 15 (주어진 자료)
 
 [32][42] 24 60 15 (0-1)
 
 32 [24][42] 60 15 (1-2)
 [24][32] 42 60 15 (0-1)
 
 24 32 42 60 15 (2-3) (변화없음)
 24 32 42 60 15 (1-2) (변화없음)
 24 32 42 60 15 (0-1) (변화없음)
 
 24 32 42 [15][60] (3-4)
 24 32 [15][42] 60 (2-3)
 24 [15][32] 42 60 (1-2)
 [15][24] 32 42 60 (0-1)
 
 */



package basic_algorithm.insertionsortAlorithm;

public class insertionsortExample {

	public static void main(String[] args) {
		
		int[] insertion = {42, 32, 24, 60, 15};

		//오름차순 삽입정렬
		for(int i=1; i<insertion.length; i++) {
			for(int j=i; j>0; j--) {
				if(insertion[j] < insertion[j-1]) {
					int tmp = insertion[j];
					insertion[j] = insertion[j-1];
					insertion[j-1] = tmp;
				}
			}
		}
		for(int i=0; i<insertion.length; i++) {
			System.out.print(insertion[i]+", ");
		}
	}

}
